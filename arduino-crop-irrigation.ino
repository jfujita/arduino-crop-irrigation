#include <Wire.h>
#include "U8glib.h"
U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE|U8G_I2C_OPT_DEV_0);    // I2C
#include "Wire.h"
#include "RTClib.h"
RTC_DS1307 RTC;

// set watering runtime in seconds
unsigned long water_for_seconds = 25;

// set water intervals in hours
unsigned long watering_interval_hours = 6;

// set water relays
int relay1 = 6;
int relay2 = 8;
int relay3 = 9;
int relay4 = 10;

// set water pump
int pump = 4;

// set button
int button = 12;

//pump state    1:open   0:close
int pump_state_flag = 0;

//relay1 state    1:open   0:close
int relay1_state_flag = 0;

//relay2 state   1:open   0:close
int relay2_state_flag = 0;

//relay3 state  1:open   0:close
int relay3_state_flag = 0;

//relay4 state   1:open   0:close
int relay4_state_flag = 0;


// good tomato
unsigned char bitmap_tomato_good[] U8G_PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x80, 0x05, 0x00, 
  0x00, 0x80, 0x04, 0x00, 0x00, 0xC8, 0x02, 0x00, 0x00, 0x7C, 0x3F, 0x00, 
  0x00, 0x6C, 0x67, 0x00, 0x00, 0x4F, 0xF3, 0x00, 0x80, 0x49, 0x9D, 0x01, 
  0xC0, 0x3E, 0x1A, 0x03, 0x60, 0x34, 0x3E, 0x06, 0x30, 0x60, 0x03, 0x0C, 
  0x18, 0xC0, 0x01, 0x08, 0x18, 0x00, 0x00, 0x18, 0x08, 0x00, 0x00, 0x10, 
  0x0C, 0x18, 0x0C, 0x30, 0x2C, 0x18, 0x0C, 0x30, 0x2C, 0x00, 0x00, 0x30, 
  0x2C, 0x00, 0x00, 0x30, 0x68, 0x08, 0x10, 0x10, 0xD8, 0x18, 0x18, 0x18, 
  0x90, 0x30, 0x0C, 0x08, 0xB0, 0xE1, 0x07, 0x0C, 0x60, 0x00, 0x00, 0x06, 
  0xC0, 0x00, 0x00, 0x03, 0x00, 0x07, 0xC0, 0x01, 0x00, 0x1E, 0x7C, 0x00, 
  0x00, 0xF0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

// bad tomato
unsigned char bitmap_tomato_bad[] U8G_PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x80, 0x05, 0x00, 
  0x00, 0x80, 0x04, 0x00, 0x00, 0xC8, 0x02, 0x00, 0x00, 0x7C, 0x3F, 0x00, 
  0x00, 0x6C, 0x67, 0x00, 0x00, 0x4F, 0xF3, 0x00, 0x80, 0x59, 0x9D, 0x01, 
  0xC0, 0x1E, 0x1A, 0x03, 0x60, 0x34, 0x3F, 0x06, 0x30, 0x60, 0x01, 0x0C, 
  0x18, 0xC8, 0x09, 0x08, 0x18, 0x90, 0x04, 0x18, 0x08, 0x20, 0x02, 0x10, 
  0x0C, 0x18, 0x0C, 0x30, 0x2C, 0x18, 0x0C, 0x30, 0x2C, 0x00, 0x00, 0x30, 
  0x2C, 0x00, 0x00, 0x30, 0x68, 0x00, 0x00, 0x10, 0xD8, 0xF8, 0x0F, 0x18, 
  0x90, 0xF8, 0x0F, 0x08, 0x30, 0x01, 0x00, 0x0C, 0x60, 0x01, 0x00, 0x06, 
  0xC0, 0x00, 0x00, 0x03, 0x00, 0x03, 0xC0, 0x01, 0x00, 0x3E, 0x7C, 0x00, 
  0x00, 0xF8, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// good pineapple
unsigned char bitmap_pineapple_good[] U8G_PROGMEM = {
  0x00, 0x38, 0x1C, 0x00, 0x00, 0x70, 0x0F, 0x00, 0x00, 0xA0, 0x05, 0x00, 
  0x00, 0x3C, 0x3D, 0x00, 0x00, 0x7C, 0x3F, 0x00, 0x00, 0xD8, 0x1B, 0x00, 
  0x00, 0x90, 0x0C, 0x00, 0x00, 0x76, 0x56, 0x00, 0x00, 0x7E, 0x7E, 0x00, 
  0x00, 0xCC, 0x31, 0x00, 0x00, 0x18, 0x1B, 0x00, 0x00, 0x30, 0x0E, 0x00, 
  0x00, 0xE0, 0x0F, 0x00, 0x00, 0x38, 0x18, 0x00, 0x00, 0x0C, 0x30, 0x00, 
  0x00, 0x04, 0x20, 0x00, 0x00, 0x62, 0x46, 0x00, 0x00, 0x03, 0xC0, 0x00, 
  0x00, 0x63, 0x46, 0x00, 0x00, 0x62, 0xC6, 0x00, 0x00, 0x01, 0xC0, 0x00, 
  0x00, 0x03, 0x80, 0x00, 0x00, 0x13, 0xC8, 0x00, 0x00, 0x22, 0xC4, 0x00, 
  0x00, 0xC2, 0x43, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x06, 0x60, 0x00, 
  0x00, 0x0C, 0x30, 0x00, 0x00, 0x78, 0x1E, 0x00, 0x00, 0xE0, 0x07, 0x00,
};

// bad pineapple
unsigned char bitmap_pineapple_bad[] U8G_PROGMEM = {
  0x00, 0x38, 0x1C, 0x00, 0x00, 0x70, 0x0F, 0x00, 0x00, 0xA0, 0x07, 0x00, 
  0x00, 0x3C, 0x3D, 0x00, 0x00, 0x7C, 0x3F, 0x00, 0x00, 0xD8, 0x19, 0x00, 
  0x00, 0x90, 0x0D, 0x00, 0x00, 0x76, 0x6C, 0x00, 0x00, 0x7E, 0x7E, 0x00, 
  0x00, 0xCC, 0x31, 0x00, 0x00, 0x18, 0x1B, 0x00, 0x00, 0x30, 0x0E, 0x00, 
  0x00, 0xE0, 0x0F, 0x00, 0x00, 0x38, 0x18, 0x00, 0x00, 0x0C, 0x30, 0x00, 
  0x00, 0x24, 0x24, 0x00, 0x00, 0x42, 0x42, 0x00, 0x00, 0x03, 0xC0, 0x00, 
  0x00, 0x63, 0x46, 0x00, 0x00, 0x62, 0xC6, 0x00, 0x00, 0x01, 0xC0, 0x00, 
  0x00, 0x03, 0x80, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0xE2, 0xC7, 0x00, 
  0x00, 0x02, 0x40, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x06, 0x60, 0x00, 
  0x00, 0x0C, 0x30, 0x00, 0x00, 0x38, 0x1C, 0x00, 0x00, 0xE0, 0x0F, 0x00,
};

static unsigned char bitmap_T[] U8G_PROGMEM = {
  0xF7, 0x01, 0x1D, 0x03, 0x0B, 0x02, 0x0C, 0x02, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x08, 0x02,
  0x18, 0x03, 0xF0, 0x01
};

static unsigned char bitmap_H[] U8G_PROGMEM = {
  0x00, 0x00, 0x80, 0x01, 0xC0, 0x03, 0xE0, 0x07, 0xF0, 0x0F, 0xF8, 0x1F, 0xF8, 0x1F, 0xFC, 0x3F,
  0xFC, 0x3F, 0xFE, 0x7F, 0xEE, 0x7F, 0xB3, 0xF7, 0xBB, 0xFB, 0xBB, 0xFD, 0xBB, 0xFD, 0xC7, 0xFE,
  0x7F, 0xC3, 0x3F, 0xDD, 0xBF, 0xFD, 0xDF, 0xDD, 0xEE, 0x5B, 0xFE, 0x7F, 0xFC, 0x3F, 0xF8, 0x1F,
  0xE0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


void setup()
{
  Serial.begin(9600);
  Serial.print("Starting smart irrigation system");
  Wire.begin();
  RTC.begin();
  // declare relay as output
  pinMode(relay1, OUTPUT);
  pinMode(relay2, OUTPUT);
  pinMode(relay3, OUTPUT);
  pinMode(relay4, OUTPUT);
  // declare pump as output
  pinMode(pump, OUTPUT);
  // declare switch as input
  pinMode(button, INPUT);
  // close all valves
  digitalWrite(relay1, LOW);
  digitalWrite(relay2, LOW);
  digitalWrite(relay3, LOW);
  digitalWrite(relay4, LOW);
  // turn off pump
  digitalWrite(pump, LOW);
  // water_crops();
}

void loop()
{
  // Water the plants on start... then wait watering_interval_hours hours
  water_crops();
  unsigned long wait_for_ms;
  Serial.println("Calculating timer interval");
  wait_for_ms = calc_timer_interval();
  Serial.println("Got calc_timer_interval()");
  Serial.println(wait_for_ms);
  delay(wait_for_ms);
}

unsigned long calc_timer_interval()
{
  // Delay 12 hours ((43200000 ms) - total cycle time for crop waterings ~(10 seconds + 2050ms for assorted delays = 12050ms) * 3 crops = (36150ms)) = 43163850 ms for perfect 12 hour delays.
  // Delay 3 hours ((10800000 ms) - total cycle time for crop waterings ~(10 seconds + 2050ms for assorted delays = 12050ms) * 3 crops = (36150ms)) = 10763850 ms for perfect 3 hour delays.
  // Delay 1 hours ((3600000 ms) - total cycle time for crop waterings ~(10 seconds + 2050ms for assorted delays = 12050ms) * 3 crops = (36150ms)) = 3563850 ms for perfect 1 hour delays.
  
  // Total cycle time = watering time + 2050 safety delays, * 3 plants to water
  unsigned long cycle_time;
  unsigned long watering_interval;
  // Potential for int (3) overflow via multiplication... cast to Unsigned Integer (UL) which should handle values from 0 to 4,294,967,295
  cycle_time = ((15 * 1000) + 2050) * 3UL;
  // Watering interval = x hours - cycle_time for exact alignment
  watering_interval = (watering_interval_hours * 60 * 60 * 1000) - cycle_time;
  return watering_interval;
}


void water_crops()
{
  digitalWrite(relay1, LOW);
  digitalWrite(relay2, LOW);
  digitalWrite(relay3, LOW);
  digitalWrite(relay4, LOW);
  
  // Open valve 1
  digitalWrite(relay1, HIGH);
  relay1_state_flag = 1;
  delay(50);
  // Turn on pump
  toggle_pump();
  // Water for designated coefficient in seconds
  delay(water_for_seconds * 1000);
  // Signal valve 1 is closing
  relay1_state_flag = 0;
  // Pump to turn off based on above signal
  toggle_pump();
  // Close valve
  digitalWrite(relay1, LOW);

  // Open valve 2
  digitalWrite(relay2, HIGH);
  relay2_state_flag = 1;
  delay(50);
  // Turn on pump
  toggle_pump();
  // Water for designated coefficient in seconds
  delay(water_for_seconds * 1000);
  // Signal valve 2 is closing
  relay2_state_flag = 0;
  // Pump to turn off based on above signal
  toggle_pump();
  // Close valve
  digitalWrite(relay2, LOW);

  // Open valve 3
  digitalWrite(relay3, HIGH);
  relay3_state_flag = 1;
  delay(50);
  // Turn on pump
  toggle_pump();
  // Water for designated coefficient in seconds
  delay(water_for_seconds * 1000);
  // Signal valve 3 is closing
  relay3_state_flag = 0;
  // Pump to turn off based on above signal
  toggle_pump();
  // Close valve
  digitalWrite(relay3, LOW);
  

  // Open valve 4
  /*
  digitalWrite(relay4, HIGH);
  relay4_state_flag = 1;
  delay(50);
  // Turn on pump
  toggle_pump();
  // Water for designated coefficient in seconds
  delay(water_for_seconds * 1000);
  // Signal valve 4 is closing
  relay4_state_flag = 0;
  // Pump to turn off based on above signal
  toggle_pump();
  // Close valve
  digitalWrite(relay4, LOW);
  */
}

void toggle_pump()
{
  // Only turn on the pump if at least one valve is open to prevent overpressurizing water supply manifold
  if ((relay1_state_flag == 1) || (relay2_state_flag == 1) || (relay3_state_flag == 1) || (relay4_state_flag == 1))
  {
    // If pump isn't already on wait 1 seconds to allow solenoids to open fully to prevent overpressure
    if(pump_state_flag == 0)
    {
      delay(1000);
    }
    pump_state_flag = 1;
    digitalWrite(pump, HIGH);
  }
  else //No valves are open... turn off pump
  {
    // If pump is running, turn off and wait 1 seconds before returning so lines depressurize before valves close
    if(pump_state_flag == 1)
    {
      pump_state_flag = 0;
      digitalWrite(pump, LOW);
      //Wait 1 seconds before returning so lines depressurize before valves close
      delay(1000);
    }
    else //Double check pump de-energized
    {
      pump_state_flag = 0;
      digitalWrite(pump, LOW);
    }
  }
}
